[应用案例](https://blog.golang.org/context)

Incoming requests to a server should create a Context.
outgoing calls to servers should accept a Context.
    Request和Context实例一一对应, 所以在请求一开始到来时就创建Context实例.
    Request handlers often start additional goroutines to access backends such as databases and RPC services.
    单起一个协程完成请求的好处：一旦第三方service响应时间过长，可取消该请求.


取消请求的情况，如下：
    1. 取消整个请求，返回给用户失败
    2. 取消部分请求，返回部分信息
    3. 同一个请求，法向了多个主机，一旦获取第一个响应，即可取消其它请求.


The chain of function calls between them must propagate the Context,
optionally replacing it with a *derived Context* created using:

1. func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
2. func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
3. func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)

When a Context is canceled, all Contexts derived from it are also canceled.
显然，Context的这个特性即可满足取消请求的各种情况.


type CancelFunc func()
Calling the CancelFunc cancels the child and its children, removes the parent's
reference to the child, and stops any associated timers.
NOTE: Failing to call the CancelFunc leaks the child and its children
The go vet tool checks that CancelFuncs are used on all control-flow paths.


Programs that use Contexts should follow these rules to keep interfaces
consistent across packages and enable static analysis tools to check context propagation:
After the first call, subsequent calls to a CancelFunc do nothing. 可多次调用很重要
1. Do not store Contexts inside a struct type; instead, pass a Context explicitly to
 	each function that needs it. The Context should be the first parameter
2. Do not pass a nil Context, even if a function permits it. Pass context.TODO
 	if you are unsure about which Context to use.
3. Use context Values only for request-scoped data that transits processes and APIs,
 	not for passing optional parameters to functions.
4. Contexts are safe for simultaneous use by multiple goroutines
